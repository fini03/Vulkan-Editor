	static std::vector<char> readFile(const std::string& filename) {
	    std::ifstream file(filename, std::ios::ate | std::ios::binary);

	    if (!file.is_open()) {
	        throw std::runtime_error("failed to open file!");
	    }

	    size_t fileSize = (size_t) file.tellg();
	    std::vector<char> buffer(fileSize);

	    file.seekg(0);
	    file.read(buffer.data(), fileSize);

	    file.close();

	    return buffer;
	}

	VkShaderModule createShaderModule(VkDevice device, const std::vector<char>& code) {
	    VkShaderModuleCreateInfo createInfo{};
	    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	    createInfo.codeSize = code.size();
	    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

	    VkShaderModule shaderModule;
	    if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
	        throw std::runtime_error("failed to create shader module!");
	    }

	    return shaderModule;
	}

	void createGraphicsPipeline(VkDevice device, VkRenderPass renderPass, VkDescriptorSetLayout descriptorSetLayout, Pipeline& graphicsPipeline) {
	    auto vertShaderCode = readFile("{{ vertexShaderPath }}");
	    auto fragShaderCode = readFile("{{ fragmentShaderPath }}");

	    VkShaderModule vertShaderModule = createShaderModule(device, vertShaderCode);
	    VkShaderModule fragShaderModule = createShaderModule(device, fragShaderCode);

	    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
	    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
	    vertShaderStageInfo.module = vertShaderModule;
	    vertShaderStageInfo.pName = "{{ vertexEntryName }}";

	    VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
	    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	    fragShaderStageInfo.module = fragShaderModule;
	    fragShaderStageInfo.pName = "{{ fragmentEntryName }}";

	    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

	    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
	    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;

	    auto bindingDescription = Vertex::getBindingDescription();
	    auto attributeDescriptions = Vertex::getAttributeDescriptions();

	    vertexInputInfo.vertexBindingDescriptionCount = 1;
	    vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
	    vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
	    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();

	    VkPipelineViewportStateCreateInfo viewportState{};
	    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
	    viewportState.viewportCount = 1;
	    viewportState.scissorCount = 1;

	    VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
	    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	    inputAssembly.topology = {{ topologyOption }};
	    inputAssembly.primitiveRestartEnable = {{ primitiveRestart }};

	    VkPipelineRasterizationStateCreateInfo rasterizer{};
	    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
	    rasterizer.depthClampEnable = {{ depthClamp }};
	    rasterizer.rasterizerDiscardEnable = {{ rasterizerDiscard }};
	    rasterizer.polygonMode = {{ polygonMode }};
	    rasterizer.lineWidth = {{ lineWidth }};
	    rasterizer.cullMode = {{ cullMode }};
	    rasterizer.frontFace = {{ frontFace }};
	    rasterizer.depthBiasEnable = {{ depthBiasEnabled }};

	    VkPipelineMultisampleStateCreateInfo multisampling{};
	    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
	    multisampling.sampleShadingEnable = {{ sampleShading }};
	    multisampling.rasterizationSamples = {{ rasterizationSamples }};

	    VkPipelineDepthStencilStateCreateInfo depthStencil{};
	    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
	    depthStencil.depthTestEnable = {{ depthTest }};
	    depthStencil.depthWriteEnable = {{ depthWrite }};
	    depthStencil.depthCompareOp = {{ depthCompareOp }};
	    depthStencil.depthBoundsTestEnable = {{ depthBoundTest }};
	    depthStencil.stencilTestEnable = {{ stencilTest }};

	    VkPipelineColorBlendAttachmentState colorBlendAttachment{};
	    colorBlendAttachment.colorWriteMask = {{ colorWriteMask }};

	    colorBlendAttachment.blendEnable = {{ blendEnable }};

	    VkPipelineColorBlendStateCreateInfo colorBlending{};
	    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
	    colorBlending.logicOpEnable = {{ logicOpEnable }};
	    colorBlending.logicOp = {{ logicOp }};
	    colorBlending.attachmentCount = {{ attachmentCount }};
	    colorBlending.pAttachments = &colorBlendAttachment;
	    colorBlending.blendConstants[0] = {{ blendConstants.0 }};
	    colorBlending.blendConstants[1] = {{ blendConstants.1 }};
	    colorBlending.blendConstants[2] = {{ blendConstants.2 }};
	    colorBlending.blendConstants[3] = {{ blendConstants.3 }};


	    std::vector<VkDynamicState> dynamicStates = {
	        VK_DYNAMIC_STATE_VIEWPORT,
	        VK_DYNAMIC_STATE_SCISSOR
	    };
	    VkPipelineDynamicStateCreateInfo dynamicState{};
	    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
	    dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
	    dynamicState.pDynamicStates = dynamicStates.data();

	    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
	    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
	    pipelineLayoutInfo.setLayoutCount = 1;
	    pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;

	    if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &graphicsPipeline.m_pipelineLayout) != VK_SUCCESS) {
	        throw std::runtime_error("failed to create pipeline layout!");
	    }

	    VkGraphicsPipelineCreateInfo pipelineInfo{};
	    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
	    pipelineInfo.stageCount = 2;
	    pipelineInfo.pStages = shaderStages;
	    pipelineInfo.pVertexInputState = &vertexInputInfo;
	    pipelineInfo.pInputAssemblyState = &inputAssembly;
	    pipelineInfo.pViewportState = &viewportState;
	    pipelineInfo.pRasterizationState = &rasterizer;
	    pipelineInfo.pMultisampleState = &multisampling;
	    pipelineInfo.pDepthStencilState = &depthStencil;
	    pipelineInfo.pColorBlendState = &colorBlending;
	    pipelineInfo.pDynamicState = &dynamicState;
	    pipelineInfo.layout = graphicsPipeline.m_pipelineLayout;
	    pipelineInfo.renderPass = renderPass;
	    pipelineInfo.subpass = 0;
	    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

	    if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline.m_pipeline) != VK_SUCCESS) {
	        throw std::runtime_error("failed to create graphics pipeline!");
	    }

	    vkDestroyShaderModule(device, fragShaderModule, nullptr);
	    vkDestroyShaderModule(device, vertShaderModule, nullptr);
	}
};

int main() {
    VulkanTutorial tutorial;

    tutorial.run();

    return EXIT_SUCCESS;
}
